<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>emonTx OEM Configuration</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 400px;
            color: #666;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e0e0e0;
            border-top-color: #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error {
            color: #f44336;
            text-align: center;
            padding: 20px;
        }
        #oem-container {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Loading OEM Configuration Interface...</p>
        <p style="font-size: 12px; color: #999;">Fetching from openenergymonitor.org</p>
    </div>
    <div id="error" class="error" style="display: none;"></div>
    <div id="oem-container"></div>

    <script>
        // WebSocket connection to Home Assistant
        let ws = null;
        let wsMessageId = 1;
        let deviceName = '';
        let outputStream = null;
        let lastJson = '';

        // Variables that the OEM interface expects
        window.app = {
            connected: false,
            button_connect_text: 'Connect',
            config_received: false
        };

        // Log element (created when OEM interface loads)
        let log = null;

        async function initConnection() {
            return new Promise((resolve, reject) => {
                const wsUrl = `ws://${window.location.host}/api/websocket`;
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);

                    switch (msg.type) {
                        case 'auth_required':
                            authenticateWithHA();
                            break;

                        case 'auth_ok':
                            console.log('Authenticated');
                            subscribeToEvents();
                            getDeviceName().then(() => resolve());
                            break;

                        case 'auth_invalid':
                            reject(new Error('Authentication failed'));
                            break;

                        case 'result':
                            if (msg.success && msg.result) {
                                handleResult(msg);
                            }
                            break;

                        case 'event':
                            if (msg.event && msg.event.event_type === 'esphome.emontx_raw') {
                                handleEmontxData(msg.event.data);
                            }
                            break;
                    }
                };

                ws.onerror = (error) => {
                    reject(error);
                };

                ws.onclose = () => {
                    console.log('WebSocket closed');
                    setTimeout(() => initConnection().catch(console.error), 5000);
                };
            });
        }

        function authenticateWithHA() {
            let token = null;

            // Try parent window
            if (window.parent && window.parent.document) {
                const hassObj = window.parent.document.querySelector('home-assistant');
                if (hassObj && hassObj.hass) {
                    token = hassObj.hass.auth.data.access_token;
                }
            }

            // Try grandparent (we're in an iframe within an iframe)
            if (!token && window.parent && window.parent.parent && window.parent.parent.document) {
                const hassObj = window.parent.parent.document.querySelector('home-assistant');
                if (hassObj && hassObj.hass) {
                    token = hassObj.hass.auth.data.access_token;
                }
            }

            if (!token) {
                const hassTokens = localStorage.getItem('hassTokens');
                if (hassTokens) {
                    try {
                        const tokens = JSON.parse(hassTokens);
                        token = tokens.access_token;
                    } catch (e) {}
                }
            }

            if (token) {
                ws.send(JSON.stringify({
                    type: 'auth',
                    access_token: token
                }));
            }
        }

        function subscribeToEvents() {
            ws.send(JSON.stringify({
                id: wsMessageId++,
                type: 'subscribe_events',
                event_type: 'esphome.emontx_raw'
            }));
        }

        let servicesPromiseResolve = null;

        function getDeviceName() {
            return new Promise((resolve) => {
                servicesPromiseResolve = resolve;
                ws.send(JSON.stringify({
                    id: wsMessageId++,
                    type: 'get_services'
                }));
            });
        }

        function handleResult(msg) {
            if (servicesPromiseResolve && msg.result) {
                const services = msg.result;
                if (services.esphome) {
                    for (const serviceName of Object.keys(services.esphome)) {
                        if (serviceName.endsWith('_send_command')) {
                            deviceName = serviceName.replace('_send_command', '');
                            console.log('Found device:', deviceName);
                            break;
                        }
                    }
                }
                servicesPromiseResolve();
                servicesPromiseResolve = null;
            }
        }

        function handleEmontxData(data) {
            const payload = data.payload || JSON.stringify(data);

            if (payload && payload !== lastJson && payload !== '{}') {
                lastJson = payload;

                // Update log if it exists
                if (log) {
                    log.textContent += payload + '\n';
                    log.scrollTop = log.scrollHeight;
                }

                // Call the OEM interface's process_line function
                if (typeof window.process_line === 'function') {
                    window.process_line(payload);
                }
            }
        }

        function sendToDevice(data) {
            if (!deviceName || !ws) {
                console.error('Not connected');
                return;
            }

            ws.send(JSON.stringify({
                id: wsMessageId++,
                type: 'call_service',
                domain: 'esphome',
                service: deviceName + '_send_command',
                service_data: {
                    command: data
                }
            }));
        }

        // Mock connect function for OEM interface
        window.connect = async function() {
            return new Promise((resolve) => {
                window.app.connected = true;
                window.app.button_connect_text = 'Connected';

                // Set up the output stream mock
                outputStream = {
                    getWriter: () => ({
                        write: (data) => {
                            sendToDevice(data);
                        },
                        releaseLock: () => {}
                    })
                };

                // Request config after connecting
                setTimeout(() => {
                    if (!window.app.config_received && typeof window.writeToStream === 'function') {
                        window.writeToStream('l');
                    }
                }, 1000);

                resolve();
            });
        };

        // Mock writeToStream function
        window.writeToStream = function(data) {
            sendToDevice(data);
        };

        async function loadOEMInterface() {
            try {
                // Use a CORS proxy or fetch directly if allowed
                const response = await fetch('https://openenergymonitor.org/serial/');

                if (!response.ok) {
                    throw new Error(`HTTP error: ${response.status}`);
                }

                let html = await response.text();

                // Patch the HTML to use our connection instead of Web Serial API
                // Remove any script that uses navigator.serial
                html = html.replace(/<script[^>]*>[\s\S]*?navigator\.serial[\s\S]*?<\/script>/gi, '');

                // Remove the connect button functionality (we auto-connect)
                html = html.replace(/async function connect\(\)[\s\S]*?^}/gm, '');

                // Inject our connection code
                const injection = `
                    <script>
                    // Auto-connect on load
                    document.addEventListener('DOMContentLoaded', () => {
                        if (typeof connect === 'function') {
                            setTimeout(() => connect().catch(console.error), 500);
                        }
                    });
                    </script>
                `;

                // Insert before </body>
                html = html.replace('</body>', injection + '</body>');

                // Display the patched HTML
                document.getElementById('loading').style.display = 'none';
                document.getElementById('oem-container').style.display = 'block';
                document.getElementById('oem-container').innerHTML = html;

                // Find and store reference to log element
                log = document.getElementById('log');

                // Execute any scripts
                const scripts = document.getElementById('oem-container').querySelectorAll('script');
                scripts.forEach(script => {
                    const newScript = document.createElement('script');
                    if (script.src) {
                        newScript.src = script.src;
                    } else {
                        newScript.textContent = script.textContent;
                    }
                    document.body.appendChild(newScript);
                });

                // Trigger auto-connect
                setTimeout(() => {
                    if (typeof window.connect === 'function') {
                        window.connect().catch(console.error);
                    }
                }, 1000);

            } catch (error) {
                console.error('Failed to load OEM interface:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `
                    <h3>Unable to load OEM interface</h3>
                    <p>Error: ${error.message}</p>
                    <p>This may be due to CORS restrictions. The OEM interface is available at:</p>
                    <p><a href="https://openenergymonitor.org/serial/" target="_blank">openenergymonitor.org/serial</a></p>
                    <p>Use the Serial Terminal tab to configure your device instead.</p>
                `;
            }
        }

        // Initialize
        initConnection()
            .then(() => loadOEMInterface())
            .catch(error => {
                console.error('Connection failed:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `
                    <h3>Connection Failed</h3>
                    <p>${error.message}</p>
                    <p>Please ensure you are logged into Home Assistant.</p>
                `;
            });
    </script>
</body>
</html>
